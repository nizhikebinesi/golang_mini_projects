НЕ использовать ничего стороннего кроме основных стандартных фреймворков 
и утилит - никаких boilerplate code (даже свои собственные ранние наработки нежелательны). 
Однако, естественно, можно использовать JSON парсер и похожее фундаментальное.

Стэк:
Golang
PostgreSQL

Задание из двух частей - попроще и посложнее.
(обе части можно объединить)

I. Приложение редактирования пользователей:
1) Минимум две страницы: логин и список.
2) Возможность добавлять/удалять/редактировать пользователей и их права: полные (редактирование/добавление/удаление) и только просмотр.
3) Пользоваться можно только залогинившись и должно действовать ограничение прав.
4) HTML с запросами через Ajax REST c JSON 
(простейшее JavaScript приложение - нативно или максимум jQuery)
на фронтенде.
5) Обязательно показать использование как ORM так и raw SQL.
6) Seed базы - первый пользователь с полными правами.
7) Описание запуска проекта в виде: README.md
8) Зависимости проекта.
9) По возможности комментарии к коду (бонус).
10) Проверьте ваш проект на работоспособность.

II. Асинхронные запросы.
Можно использовать любой доступный метод для достижения “асинхронности” (concurrent computing), включая парадигмы как Reactive и т.п.
1) Есть три удаленных источника данных (в качестве источников для тестового задания то могут быть два статических JSON файла на том же сервере с массивом простых данных - ID и некое текстовое поле, содержащее в теле ID).

Пример:
```json
[
  {"id": 1, "name": "Test 1"},
  {"id": 2, "name": "Test 2"}
]
```

Источники доступны по HTTP.
В данных для каждого элемента должен быть ID.

ID распределены следующим образом:
- 1-й источник: ID 1-10,31-40;
- 2-й источник: ID 11-20,41-50;
- 3-й источник: ID 21-30,51-60;

2) Есть одна общая точка доступа до этих данных, которая выдаёт коррелированный результат.
   Точка доступна по HTTP.
3) Эта точка должна делать запросы ко всем источникам “асинхронно” и ждать результата со всех.
4) По получению результата от всех, выдать отсортированный по ID результат (данные со всех источников).
5) Ошибка от любого из источников игнорируется и интерпретируется, как отсутствие данных.
6) Ошибкой также считается таймаут (2 секунды).
